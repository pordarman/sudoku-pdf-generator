{"version":3,"file":"static/js/400.8a892a75.chunk.js","mappings":"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","sources":["utils/sudokuLogic.js","sudoku.worker.js"],"sourcesContent":["// This file contains the basic logic for Sudoku: creating an empty board,\r\n// checking if a number is valid, and finding solutions.\r\n\r\nexport const createEmptyGrid = () => Array(9).fill(null).map(() => Array(9).fill(0));\r\n\r\nexport const isValid = (grid, row, col, num) => {\r\n    // Check the row\r\n    for (let x = 0; x < 9; x++) {\r\n        if (grid[row][x] === num) return false;\r\n    }\r\n    // Check the column\r\n    for (let x = 0; x < 9; x++) {\r\n        if (grid[x][col] === num) return false;\r\n    }\r\n    // Check the 3x3 box\r\n    const startRow = row - (row % 3), startCol = col - (col % 3);\r\n    for (let i = 0; i < 3; i++) {\r\n        for (let j = 0; j < 3; j++) {\r\n            if (grid[i + startRow][j + startCol] === num) return false;\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\r\nexport const findAllSolutions = (grid, limit = 2000) => {\r\n    const solutions = [];\r\n    const find = (currentGrid) => {\r\n        // For performance, we stop after finding a maximum of 'limit' solutions.\r\n        // If we found 'limit' solutions, we inform the user that there may be more.\r\n        if (solutions.length >= limit) return;\r\n\r\n        for (let row = 0; row < 9; row++) {\r\n            for (let col = 0; col < 9; col++) {\r\n                if (currentGrid[row][col] === 0) {\r\n                    for (let num = 1; num <= 9; num++) {\r\n                        if (isValid(currentGrid, row, col, num)) {\r\n                            currentGrid[row][col] = num;\r\n                            find(currentGrid);\r\n                            currentGrid[row][col] = 0; // Backtracking\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        solutions.push(JSON.parse(JSON.stringify(currentGrid)));\r\n    };\r\n    find(JSON.parse(JSON.stringify(grid)));\r\n\r\n    return shuffle(solutions);\r\n};\r\n\r\nexport const shuffle = (array) => {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n    return array;\r\n};\r\n\r\nexport const fillGrid = (grid) => {\r\n    for (let i = 0; i < 81; i++) {\r\n        const row = Math.floor(i / 9), col = i % 9;\r\n        if (grid[row][col] === 0) {\r\n            const numbers = shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]);\r\n            for (const num of numbers) {\r\n                if (isValid(grid, row, col, num)) {\r\n                    grid[row][col] = num;\r\n                    if (fillGrid(grid)) return true;\r\n                    grid[row][col] = 0;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\r\nexport const generateSudoku = (removals) => {\r\n    let bestPuzzle = null;\r\n    let bestRemovedCount = -1;\r\n    let attempts = 0;\r\n    const maxAttempts = 10;\r\n\r\n    // Continue the loop until the target number of cells is removed or the maximum number of attempts is reached.\r\n    while (attempts < maxAttempts) {\r\n        const grid = createEmptyGrid();\r\n        fillGrid(grid); // Create a new filled board from scratch for each attempt.\r\n\r\n        const solution = JSON.parse(JSON.stringify(grid));\r\n        let puzzle = JSON.parse(JSON.stringify(solution));\r\n\r\n        // Create a random removal order by shuffling the cells.\r\n        const cells = shuffle(Array.from({ length: 81 }, (_, i) => i));\r\n        let removedCount = 0;\r\n\r\n        for (const cellIndex of cells) {\r\n            if (removedCount >= removals) break; // If the target is reached, exit the loop.\r\n\r\n            const row = Math.floor(cellIndex / 9);\r\n            const col = cellIndex % 9;\r\n\r\n            // If this cell is already empty, skip it (this shouldn't happen in this loop but it's a good check).\r\n            if (puzzle[row][col] === 0) continue;\r\n\r\n            const temp = puzzle[row][col];\r\n            puzzle[row][col] = 0;\r\n\r\n            // Check if the solution is still unique.\r\n            const solutions = findAllSolutions(puzzle, 2);\r\n            if (solutions.length !== 1) {\r\n                // If the solution is not unique, restore the removed number.\r\n                puzzle[row][col] = temp;\r\n            } else {\r\n                // If the solution is still unique, confirm the removal.\r\n                removedCount++;\r\n            }\r\n        }\r\n\r\n        // Did we reach the target at the end of this attempt?\r\n        if (removedCount >= removals) {\r\n            return { puzzle, solution };\r\n        }\r\n\r\n        // If this attempt didn't reach the target but was the best so far, keep it.\r\n        if (removedCount > bestRemovedCount) {\r\n            bestRemovedCount = removedCount;\r\n            bestPuzzle = { puzzle, solution };\r\n        }\r\n        \r\n        attempts++;\r\n    }\r\n\r\n    // If the maximum number of attempts has been reached and the target has still not been met,\r\n    // return the best attempt with a warning.\r\n    if (bestRemovedCount < removals) {\r\n        console.warn(`Maximum number of attempts reached (${maxAttempts}). Target was ${removals} cells, best result is a puzzle with ${bestRemovedCount} cells removed.`);\r\n    }\r\n\r\n    return bestPuzzle;\r\n};\r\n\r\nexport const validateGrid = (grid) => {\r\n    const invalidCells = new Set();\r\n\r\n    // Helper function to add coordinates to the set\r\n    const addInvalid = (r, c) => invalidCells.add(`${r}-${c}`);\r\n\r\n    // 1. Check rows and columns\r\n    for (let i = 0; i < 9; i++) {\r\n        const rowMap = new Map();\r\n        const colMap = new Map();\r\n        for (let j = 0; j < 9; j++) {\r\n            // Row check\r\n            const rowCell = grid[i][j];\r\n            if (rowCell !== 0) {\r\n                if (rowMap.has(rowCell)) {\r\n                    addInvalid(i, j);\r\n                    addInvalid(i, rowMap.get(rowCell));\r\n                }\r\n                rowMap.set(rowCell, j);\r\n            }\r\n            // Column check\r\n            const colCell = grid[j][i];\r\n            if (colCell !== 0) {\r\n                if (colMap.has(colCell)) {\r\n                    addInvalid(j, i);\r\n                    addInvalid(colMap.get(colCell), i);\r\n                }\r\n                colMap.set(colCell, j);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 2. Check 3x3 boxes\r\n    for (let boxRow = 0; boxRow < 9; boxRow += 3) {\r\n        for (let boxCol = 0; boxCol < 9; boxCol += 3) {\r\n            const boxMap = new Map();\r\n            for (let i = 0; i < 3; i++) {\r\n                for (let j = 0; j < 3; j++) {\r\n                    const r = boxRow + i;\r\n                    const c = boxCol + j;\r\n                    const cellValue = grid[r][c];\r\n                    if (cellValue !== 0) {\r\n                        if (boxMap.has(cellValue)) {\r\n                            const [prev_r, prev_c] = boxMap.get(cellValue);\r\n                            addInvalid(r, c);\r\n                            addInvalid(prev_r, prev_c);\r\n                        }\r\n                        boxMap.set(cellValue, [r, c]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Convert the Set to an array of {row, col} objects\r\n    return Array.from(invalidCells).map(coord => {\r\n        const [row, col] = coord.split('-').map(Number);\r\n        return { row, col };\r\n    });\r\n};","/* eslint-disable no-restricted-globals */\r\nimport { generateSudoku } from \"./utils/sudokuLogic.js\";\r\n\r\nfunction numberToTime(estimatedTime) {\r\n    const minutes = Math.floor(estimatedTime / 60000);\r\n    const seconds = Math.floor((estimatedTime % 60000) / 1000);\r\n    return `${minutes}m ${seconds}s`;\r\n}\r\n\r\nself.onmessage = (e) => {\r\n    const { totalSudokus, chosenDifficulties, difficultySettings } = e.data;\r\n\r\n    const generatedPuzzles = [];\r\n\r\n    const numSelected = chosenDifficulties.length;\r\n    const sudokusPerDifficulty = Math.floor(totalSudokus / numSelected);\r\n    const remainder = totalSudokus % numSelected;\r\n\r\n    let counts = chosenDifficulties.map((_, idx) =>\r\n        sudokusPerDifficulty + (idx < remainder ? 1 : 0)\r\n    );\r\n\r\n    let estimatedTime = counts.reduce((sum, count, idx) => {\r\n        const difficultyKey = chosenDifficulties[idx];\r\n        const difficulty = difficultySettings[difficultyKey];\r\n        return sum + (count * difficulty.estimatedTime);\r\n    }, 0);\r\n\r\n    self.postMessage({\r\n        type: 'progress',\r\n        generated: 0,\r\n        total: totalSudokus,\r\n        estimatedTime: numberToTime(estimatedTime)\r\n    });\r\n\r\n    for (let d = 0; d < chosenDifficulties.length; d++) {\r\n        const difficultyKey = chosenDifficulties[d];\r\n        const difficulty = difficultySettings[difficultyKey];\r\n        for (let i = 0; i < counts[d]; i++) {\r\n\r\n            const result = generateSudoku(difficulty.removals);\r\n\r\n            if (result) generatedPuzzles.push({\r\n                puzzle: result.puzzle,\r\n                solution: result.solution,\r\n                difficulty: difficulty.level,\r\n            });\r\n\r\n            estimatedTime -= difficulty.estimatedTime;\r\n\r\n            // Post the message when a puzzle is generated\r\n            self.postMessage({\r\n                type: 'progress',\r\n                generated: generatedPuzzles.length,\r\n                total: totalSudokus,\r\n                estimatedTime: numberToTime(estimatedTime)\r\n            });\r\n        }\r\n    }\r\n\r\n    self.postMessage({\r\n        type: 'result',\r\n        puzzles: generatedPuzzles\r\n    });\r\n};"],"names":["createEmptyGrid","Array","fill","map","isValid","grid","row","col","num","x","startRow","startCol","i","j","findAllSolutions","limit","arguments","length","undefined","solutions","find","currentGrid","push","JSON","parse","stringify","shuffle","array","Math","floor","random","fillGrid","numbers","generateSudoku","removals","bestPuzzle","bestRemovedCount","attempts","solution","puzzle","cells","from","_","removedCount","cellIndex","temp","console","warn","concat","numberToTime","estimatedTime","minutes","seconds","self","onmessage","e","totalSudokus","chosenDifficulties","difficultySettings","data","generatedPuzzles","numSelected","sudokusPerDifficulty","remainder","counts","idx","reduce","sum","count","difficultyKey","postMessage","type","generated","total","d","difficulty","result","level","puzzles"],"sourceRoot":""}