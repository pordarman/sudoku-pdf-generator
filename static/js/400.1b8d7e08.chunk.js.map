{"version":3,"file":"static/js/400.1b8d7e08.chunk.js","mappings":"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","sources":["utils/sudokuLogic.js","sudoku.worker.js"],"sourcesContent":["// src/utils/sudokuLogic.js\r\n// Bu dosya, Sudoku'nun temel mantığını içerir: boş bir tablo oluşturma,\r\n// bir sayının geçerli olup olmadığını kontrol etme ve çözümleri bulma.\r\n\r\nexport const createEmptyGrid = () => Array(9).fill(null).map(() => Array(9).fill(0));\r\n\r\nexport const isValid = (grid, row, col, num) => {\r\n    // Satırı kontrol et\r\n    for (let x = 0; x < 9; x++) {\r\n        if (grid[row][x] === num) return false;\r\n    }\r\n    // Sütunu kontrol et\r\n    for (let x = 0; x < 9; x++) {\r\n        if (grid[x][col] === num) return false;\r\n    }\r\n    // 3x3'lük kutuyu kontrol et\r\n    const startRow = row - (row % 3), startCol = col - (col % 3);\r\n    for (let i = 0; i < 3; i++) {\r\n        for (let j = 0; j < 3; j++) {\r\n            if (grid[i + startRow][j + startCol] === num) return false;\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\r\nexport const findAllSolutions = (grid, limit = 2000) => {\r\n    const solutions = [];\r\n    const find = (currentGrid) => {\r\n        // Performans için en fazla limit tane çözüm bulup duruyoruz.\r\n        // Eğer limit tane çözüm bulunduysa kullanıcıya \"limit tane çözüm bulundu ama daha fazla olabilir diyoruz\"\r\n        if (solutions.length >= limit) return;\r\n\r\n        for (let row = 0; row < 9; row++) {\r\n            for (let col = 0; col < 9; col++) {\r\n                if (currentGrid[row][col] === 0) {\r\n                    for (let num = 1; num <= 9; num++) {\r\n                        if (isValid(currentGrid, row, col, num)) {\r\n                            currentGrid[row][col] = num;\r\n                            find(currentGrid);\r\n                            currentGrid[row][col] = 0; // Geri izleme (Backtracking)\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        // Derin bir kopya alarak çözümü kaydet\r\n        solutions.push(JSON.parse(JSON.stringify(currentGrid)));\r\n    };\r\n    // Fonksiyonu başlat\r\n    find(JSON.parse(JSON.stringify(grid)));\r\n\r\n    // Sonuçları karıştırarak ver\r\n    return shuffle(solutions);\r\n};\r\n\r\nexport const shuffle = (array) => {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n    return array;\r\n};\r\n\r\nexport const fillGrid = (grid) => {\r\n    for (let i = 0; i < 81; i++) {\r\n        const row = Math.floor(i / 9), col = i % 9;\r\n        if (grid[row][col] === 0) {\r\n            const numbers = shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]);\r\n            for (const num of numbers) {\r\n                if (isValid(grid, row, col, num)) {\r\n                    grid[row][col] = num;\r\n                    if (fillGrid(grid)) return true;\r\n                    grid[row][col] = 0;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\r\nexport const generateSudoku = (removals) => {\r\n    const grid = createEmptyGrid();\r\n    fillGrid(grid);\r\n    const solution = JSON.parse(JSON.stringify(grid));\r\n    let puzzle = JSON.parse(JSON.stringify(solution));\r\n    const cells = shuffle(Array.from({ length: 81 }, (_, i) => i));\r\n    let removedCount = 0;\r\n    for (const cellIndex of cells) {\r\n        if (removedCount >= removals) break;\r\n        const row = Math.floor(cellIndex / 9), col = cellIndex % 9;\r\n        if (puzzle[row][col] === 0) continue;\r\n        const temp = puzzle[row][col];\r\n        puzzle[row][col] = 0;\r\n        const solutions = findAllSolutions(puzzle, 2);\r\n        if (solutions.length !== 1) {\r\n            puzzle[row][col] = temp;\r\n        } else {\r\n            removedCount++;\r\n        }\r\n    }\r\n    return { puzzle, solution };\r\n};\r\n\r\nexport const validateGrid = (grid) => {\r\n    const invalidCells = new Set();\r\n\r\n    // Helper function to add coordinates to the set\r\n    const addInvalid = (r, c) => invalidCells.add(`${r}-${c}`);\r\n\r\n    // 1. Satırları ve Sütunları kontrol et\r\n    for (let i = 0; i < 9; i++) {\r\n        const rowMap = new Map();\r\n        const colMap = new Map();\r\n        for (let j = 0; j < 9; j++) {\r\n            // Satır kontrolü\r\n            const rowCell = grid[i][j];\r\n            if (rowCell !== 0) {\r\n                if (rowMap.has(rowCell)) {\r\n                    addInvalid(i, j);\r\n                    addInvalid(i, rowMap.get(rowCell));\r\n                }\r\n                rowMap.set(rowCell, j);\r\n            }\r\n            // Sütun kontrolü\r\n            const colCell = grid[j][i];\r\n            if (colCell !== 0) {\r\n                if (colMap.has(colCell)) {\r\n                    addInvalid(j, i);\r\n                    addInvalid(colMap.get(colCell), i);\r\n                }\r\n                colMap.set(colCell, j);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 2. 3x3'lük Kutuları kontrol et\r\n    for (let boxRow = 0; boxRow < 9; boxRow += 3) {\r\n        for (let boxCol = 0; boxCol < 9; boxCol += 3) {\r\n            const boxMap = new Map();\r\n            for (let i = 0; i < 3; i++) {\r\n                for (let j = 0; j < 3; j++) {\r\n                    const r = boxRow + i;\r\n                    const c = boxCol + j;\r\n                    const cellValue = grid[r][c];\r\n                    if (cellValue !== 0) {\r\n                        if (boxMap.has(cellValue)) {\r\n                            const [prev_r, prev_c] = boxMap.get(cellValue);\r\n                            addInvalid(r, c);\r\n                            addInvalid(prev_r, prev_c);\r\n                        }\r\n                        boxMap.set(cellValue, [r, c]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Set'i {row, col} objelerinden oluşan bir array'e dönüştür\r\n    return Array.from(invalidCells).map(coord => {\r\n        const [row, col] = coord.split('-').map(Number);\r\n        return { row, col };\r\n    });\r\n};","/* eslint-disable no-restricted-globals */\r\nimport { generateSudoku } from \"./utils/sudokuLogic.js\";\r\n\r\nself.onmessage = (e) => {\r\n    console.log('Worker: Mesaj alındı', e.data);\r\n    const { totalSudokus, chosenDifficulties, difficultySettings } = e.data;\r\n\r\n    const generatedPuzzles = [];\r\n\r\n    const numSelected = chosenDifficulties.length;\r\n    const sudokusPerDifficulty = Math.floor(totalSudokus / numSelected);\r\n    const remainder = totalSudokus % numSelected;\r\n\r\n    let counts = chosenDifficulties.map((_, idx) =>\r\n        sudokusPerDifficulty + (idx < remainder ? 1 : 0)\r\n    );\r\n\r\n    for (let d = 0; d < chosenDifficulties.length; d++) {\r\n        const difficultyKey = chosenDifficulties[d];\r\n        const difficulty = difficultySettings[difficultyKey];\r\n        for (let i = 0; i < counts[d]; i++) {\r\n\r\n            const { puzzle, solution } = generateSudoku(difficulty.removals);\r\n\r\n            generatedPuzzles.push({\r\n                puzzle,\r\n                solution,\r\n                difficulty: difficulty.level,\r\n            });\r\n        }\r\n    }\r\n\r\n    // İş bittiğinde, oluşturulan bulmacaları ana thread'e geri gönder.\r\n    console.log('Worker: İşlem tamamlandı, sonuç gönderiliyor.');\r\n    self.postMessage(generatedPuzzles);\r\n};"],"names":["isValid","grid","row","col","num","x","startRow","startCol","i","j","findAllSolutions","limit","arguments","length","undefined","solutions","find","currentGrid","push","JSON","parse","stringify","shuffle","array","Math","floor","random","fillGrid","numbers","generateSudoku","removals","Array","fill","map","solution","puzzle","cells","from","_","removedCount","cellIndex","temp","self","onmessage","e","console","log","data","totalSudokus","chosenDifficulties","difficultySettings","generatedPuzzles","numSelected","sudokusPerDifficulty","remainder","counts","idx","d","difficulty","level","postMessage"],"sourceRoot":""}