{"version":3,"file":"static/js/269.6dbc3f43.chunk.js","mappings":"mBAGO,MAEMA,EAAUA,CAACC,EAAMC,EAAKC,EAAKC,KAEpC,IAAK,IAAIC,EAAI,EAAGA,EAAI,EAAGA,IACnB,GAAIJ,EAAKC,GAAKG,KAAOD,EAAK,OAAO,EAGrC,IAAK,IAAIC,EAAI,EAAGA,EAAI,EAAGA,IACnB,GAAIJ,EAAKI,GAAGF,KAASC,EAAK,OAAO,EAGrC,MAAME,EAAWJ,EAAOA,EAAM,EAAIK,EAAWJ,EAAOA,EAAM,EAC1D,IAAK,IAAIK,EAAI,EAAGA,EAAI,EAAGA,IACnB,IAAK,IAAIC,EAAI,EAAGA,EAAI,EAAGA,IACnB,GAAIR,EAAKO,EAAIF,GAAUG,EAAIF,KAAcH,EAAK,OAAO,EAG7D,OAAO,GAGEM,EAAmB,SAACT,GAAwB,IAAlBU,EAAKC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,IAC3C,MAAMG,EAAY,GACZC,EAAQC,IAGV,KAAIF,EAAUF,QAAUF,GAAxB,CAEA,IAAK,IAAIT,EAAM,EAAGA,EAAM,EAAGA,IACvB,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,IACvB,GAA8B,IAA1Bc,EAAYf,GAAKC,GAAY,CAC7B,IAAK,IAAIC,EAAM,EAAGA,GAAO,EAAGA,IACpBJ,EAAQiB,EAAaf,EAAKC,EAAKC,KAC/Ba,EAAYf,GAAKC,GAAOC,EACxBY,EAAKC,GACLA,EAAYf,GAAKC,GAAO,GAGhC,MACJ,CAGRY,EAAUG,KAAKC,KAAKC,MAAMD,KAAKE,UAAUJ,IAhBJ,GAoBzC,OAFAD,EAAKG,KAAKC,MAAMD,KAAKE,UAAUpB,KAExBqB,EAAQP,EACnB,EAEaO,EAAWC,IACpB,IAAK,IAAIf,EAAIe,EAAMV,OAAS,EAAGL,EAAI,EAAGA,IAAK,CACvC,MAAMC,EAAIe,KAAKC,MAAMD,KAAKE,UAAYlB,EAAI,KACzCe,EAAMf,GAAIe,EAAMd,IAAM,CAACc,EAAMd,GAAIc,EAAMf,GAC5C,CACA,OAAOe,GCtDXI,KAAKC,UAAaC,IACd,MAAM,OAAEC,EAAM,aAAEC,GAAiBF,EAAEG,KAE7BjB,EAAYL,EAAiBoB,EAAQC,GAC3CJ,KAAKM,YAAY,CACbC,KAAM,SACNnB,c","sources":["utils/sudokuLogic.js","findAllSolutions.worker.js"],"sourcesContent":["// This file contains the basic logic for Sudoku: creating an empty board,\r\n// checking if a number is valid, and finding solutions.\r\n\r\nexport const createEmptyGrid = () => Array(9).fill(null).map(() => Array(9).fill(0));\r\n\r\nexport const isValid = (grid, row, col, num) => {\r\n    // Check the row\r\n    for (let x = 0; x < 9; x++) {\r\n        if (grid[row][x] === num) return false;\r\n    }\r\n    // Check the column\r\n    for (let x = 0; x < 9; x++) {\r\n        if (grid[x][col] === num) return false;\r\n    }\r\n    // Check the 3x3 box\r\n    const startRow = row - (row % 3), startCol = col - (col % 3);\r\n    for (let i = 0; i < 3; i++) {\r\n        for (let j = 0; j < 3; j++) {\r\n            if (grid[i + startRow][j + startCol] === num) return false;\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\r\nexport const findAllSolutions = (grid, limit = 2000) => {\r\n    const solutions = [];\r\n    const find = (currentGrid) => {\r\n        // For performance, we stop after finding a maximum of 'limit' solutions.\r\n        // If we found 'limit' solutions, we inform the user that there may be more.\r\n        if (solutions.length >= limit) return;\r\n\r\n        for (let row = 0; row < 9; row++) {\r\n            for (let col = 0; col < 9; col++) {\r\n                if (currentGrid[row][col] === 0) {\r\n                    for (let num = 1; num <= 9; num++) {\r\n                        if (isValid(currentGrid, row, col, num)) {\r\n                            currentGrid[row][col] = num;\r\n                            find(currentGrid);\r\n                            currentGrid[row][col] = 0; // Backtracking\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        solutions.push(JSON.parse(JSON.stringify(currentGrid)));\r\n    };\r\n    find(JSON.parse(JSON.stringify(grid)));\r\n\r\n    return shuffle(solutions);\r\n};\r\n\r\nexport const shuffle = (array) => {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n    return array;\r\n};\r\n\r\nexport const fillGrid = (grid) => {\r\n    for (let i = 0; i < 81; i++) {\r\n        const row = Math.floor(i / 9), col = i % 9;\r\n        if (grid[row][col] === 0) {\r\n            const numbers = shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]);\r\n            for (const num of numbers) {\r\n                if (isValid(grid, row, col, num)) {\r\n                    grid[row][col] = num;\r\n                    if (fillGrid(grid)) return true;\r\n                    grid[row][col] = 0;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\r\nexport const generateSudoku = (removals) => {\r\n    let bestPuzzle = null;\r\n    let bestRemovedCount = -1;\r\n    let attempts = 0;\r\n    const maxAttempts = 10;\r\n\r\n    // Continue the loop until the target number of cells is removed or the maximum number of attempts is reached.\r\n    while (attempts < maxAttempts) {\r\n        const grid = createEmptyGrid();\r\n        fillGrid(grid); // Create a new filled board from scratch for each attempt.\r\n\r\n        const solution = JSON.parse(JSON.stringify(grid));\r\n        let puzzle = JSON.parse(JSON.stringify(solution));\r\n\r\n        // Create a random removal order by shuffling the cells.\r\n        const cells = shuffle(Array.from({ length: 81 }, (_, i) => i));\r\n        let removedCount = 0;\r\n\r\n        for (const cellIndex of cells) {\r\n            if (removedCount >= removals) break; // If the target is reached, exit the loop.\r\n\r\n            const row = Math.floor(cellIndex / 9);\r\n            const col = cellIndex % 9;\r\n\r\n            // If this cell is already empty, skip it (this shouldn't happen in this loop but it's a good check).\r\n            if (puzzle[row][col] === 0) continue;\r\n\r\n            const temp = puzzle[row][col];\r\n            puzzle[row][col] = 0;\r\n\r\n            // Check if the solution is still unique.\r\n            const solutions = findAllSolutions(puzzle, 2);\r\n            if (solutions.length !== 1) {\r\n                // If the solution is not unique, restore the removed number.\r\n                puzzle[row][col] = temp;\r\n            } else {\r\n                // If the solution is still unique, confirm the removal.\r\n                removedCount++;\r\n            }\r\n        }\r\n\r\n        // Did we reach the target at the end of this attempt?\r\n        if (removedCount >= removals) {\r\n            return { puzzle, solution };\r\n        }\r\n\r\n        // If this attempt didn't reach the target but was the best so far, keep it.\r\n        if (removedCount > bestRemovedCount) {\r\n            bestRemovedCount = removedCount;\r\n            bestPuzzle = { puzzle, solution };\r\n        }\r\n        \r\n        attempts++;\r\n    }\r\n\r\n    // If the maximum number of attempts has been reached and the target has still not been met,\r\n    // return the best attempt with a warning.\r\n    if (bestRemovedCount < removals) {\r\n        console.warn(`Maximum number of attempts reached (${maxAttempts}). Target was ${removals} cells, best result is a puzzle with ${bestRemovedCount} cells removed.`);\r\n    }\r\n\r\n    return bestPuzzle;\r\n};\r\n\r\nexport const validateGrid = (grid) => {\r\n    const invalidCells = new Set();\r\n\r\n    // Helper function to add coordinates to the set\r\n    const addInvalid = (r, c) => invalidCells.add(`${r}-${c}`);\r\n\r\n    // 1. Check rows and columns\r\n    for (let i = 0; i < 9; i++) {\r\n        const rowMap = new Map();\r\n        const colMap = new Map();\r\n        for (let j = 0; j < 9; j++) {\r\n            // Row check\r\n            const rowCell = grid[i][j];\r\n            if (rowCell !== 0) {\r\n                if (rowMap.has(rowCell)) {\r\n                    addInvalid(i, j);\r\n                    addInvalid(i, rowMap.get(rowCell));\r\n                }\r\n                rowMap.set(rowCell, j);\r\n            }\r\n            // Column check\r\n            const colCell = grid[j][i];\r\n            if (colCell !== 0) {\r\n                if (colMap.has(colCell)) {\r\n                    addInvalid(j, i);\r\n                    addInvalid(colMap.get(colCell), i);\r\n                }\r\n                colMap.set(colCell, j);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 2. Check 3x3 boxes\r\n    for (let boxRow = 0; boxRow < 9; boxRow += 3) {\r\n        for (let boxCol = 0; boxCol < 9; boxCol += 3) {\r\n            const boxMap = new Map();\r\n            for (let i = 0; i < 3; i++) {\r\n                for (let j = 0; j < 3; j++) {\r\n                    const r = boxRow + i;\r\n                    const c = boxCol + j;\r\n                    const cellValue = grid[r][c];\r\n                    if (cellValue !== 0) {\r\n                        if (boxMap.has(cellValue)) {\r\n                            const [prev_r, prev_c] = boxMap.get(cellValue);\r\n                            addInvalid(r, c);\r\n                            addInvalid(prev_r, prev_c);\r\n                        }\r\n                        boxMap.set(cellValue, [r, c]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Convert the Set to an array of {row, col} objects\r\n    return Array.from(invalidCells).map(coord => {\r\n        const [row, col] = coord.split('-').map(Number);\r\n        return { row, col };\r\n    });\r\n};","/* eslint-disable no-restricted-globals */\r\nimport { findAllSolutions } from \"./utils/sudokuLogic.js\";\r\n\r\nself.onmessage = (e) => {\r\n    const { puzzle, maxSolutions } = e.data;\r\n\r\n    const solutions = findAllSolutions(puzzle, maxSolutions);\r\n    self.postMessage({\r\n        type: 'result',\r\n        solutions\r\n    });\r\n};"],"names":["isValid","grid","row","col","num","x","startRow","startCol","i","j","findAllSolutions","limit","arguments","length","undefined","solutions","find","currentGrid","push","JSON","parse","stringify","shuffle","array","Math","floor","random","self","onmessage","e","puzzle","maxSolutions","data","postMessage","type"],"sourceRoot":""}