{"version":3,"file":"static/js/400.1a42c5cb.chunk.js","mappings":"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","sources":["utils/sudokuLogic.js","sudoku.worker.js"],"sourcesContent":["// src/utils/sudokuLogic.js\r\n// Bu dosya, Sudoku'nun temel mantığını içerir: boş bir tablo oluşturma,\r\n// bir sayının geçerli olup olmadığını kontrol etme ve çözümleri bulma.\r\n\r\nexport const createEmptyGrid = () => Array(9).fill(null).map(() => Array(9).fill(0));\r\n\r\nexport const isValid = (grid, row, col, num) => {\r\n    // Satırı kontrol et\r\n    for (let x = 0; x < 9; x++) {\r\n        if (grid[row][x] === num) return false;\r\n    }\r\n    // Sütunu kontrol et\r\n    for (let x = 0; x < 9; x++) {\r\n        if (grid[x][col] === num) return false;\r\n    }\r\n    // 3x3'lük kutuyu kontrol et\r\n    const startRow = row - (row % 3), startCol = col - (col % 3);\r\n    for (let i = 0; i < 3; i++) {\r\n        for (let j = 0; j < 3; j++) {\r\n            if (grid[i + startRow][j + startCol] === num) return false;\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\r\nexport const findAllSolutions = (grid, limit = 2000) => {\r\n    const solutions = [];\r\n    const find = (currentGrid) => {\r\n        // Performans için en fazla limit tane çözüm bulup duruyoruz.\r\n        // Eğer limit tane çözüm bulunduysa kullanıcıya \"limit tane çözüm bulundu ama daha fazla olabilir diyoruz\"\r\n        if (solutions.length >= limit) return;\r\n\r\n        for (let row = 0; row < 9; row++) {\r\n            for (let col = 0; col < 9; col++) {\r\n                if (currentGrid[row][col] === 0) {\r\n                    for (let num = 1; num <= 9; num++) {\r\n                        if (isValid(currentGrid, row, col, num)) {\r\n                            currentGrid[row][col] = num;\r\n                            find(currentGrid);\r\n                            currentGrid[row][col] = 0; // Geri izleme (Backtracking)\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        // Derin bir kopya alarak çözümü kaydet\r\n        solutions.push(JSON.parse(JSON.stringify(currentGrid)));\r\n    };\r\n    // Fonksiyonu başlat\r\n    find(JSON.parse(JSON.stringify(grid)));\r\n\r\n    // Sonuçları karıştırarak ver\r\n    return shuffle(solutions);\r\n};\r\n\r\nexport const shuffle = (array) => {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n    return array;\r\n};\r\n\r\nexport const fillGrid = (grid) => {\r\n    for (let i = 0; i < 81; i++) {\r\n        const row = Math.floor(i / 9), col = i % 9;\r\n        if (grid[row][col] === 0) {\r\n            const numbers = shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]);\r\n            for (const num of numbers) {\r\n                if (isValid(grid, row, col, num)) {\r\n                    grid[row][col] = num;\r\n                    if (fillGrid(grid)) return true;\r\n                    grid[row][col] = 0;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\r\nexport const generateSudoku = (removals) => {\r\n    let bestPuzzle = null;\r\n    let bestRemovedCount = -1;\r\n    let attempts = 0;\r\n    const maxAttempts = 10; // Sonsuz döngüyü engellemek için bir sınır koyuyoruz.\r\n\r\n    // Hedeflenen sayıda hücre silinene kadar veya maksimum deneme sayısına ulaşana kadar döngüye devam et.\r\n    while (attempts < maxAttempts) {\r\n        const grid = createEmptyGrid();\r\n        fillGrid(grid); // Her denemede SIFIRDAN yeni bir dolu tahta oluştur.\r\n\r\n        const solution = JSON.parse(JSON.stringify(grid));\r\n        let puzzle = JSON.parse(JSON.stringify(solution));\r\n        \r\n        // Hücreleri karıştırarak rastgele bir silme sırası oluştur.\r\n        const cells = shuffle(Array.from({ length: 81 }, (_, i) => i));\r\n        let removedCount = 0;\r\n\r\n        for (const cellIndex of cells) {\r\n            if (removedCount >= removals) break; // Hedefe ulaşıldıysa döngüden çık.\r\n\r\n            const row = Math.floor(cellIndex / 9);\r\n            const col = cellIndex % 9;\r\n            \r\n            // Bu hücre zaten boşsa atla (bu döngüde olmaz ama iyi bir kontrol).\r\n            if (puzzle[row][col] === 0) continue;\r\n\r\n            const temp = puzzle[row][col];\r\n            puzzle[row][col] = 0;\r\n\r\n            // Çözümün hala tek olup olmadığını kontrol et.\r\n            const solutions = findAllSolutions(puzzle, 2);\r\n            if (solutions.length !== 1) {\r\n                // Eğer çözüm tek değilse, sildiğin sayıyı geri koy.\r\n                puzzle[row][col] = temp;\r\n            } else {\r\n                // Çözüm hala tek ise, silme işlemini onayla.\r\n                removedCount++;\r\n            }\r\n        }\r\n\r\n        // Bu denemenin sonunda hedefe ulaştık mı?\r\n        if (removedCount >= removals) {\r\n            console.log(`Başarılı! ${removals} hücre ${attempts + 1}. denemede silindi.`);\r\n            return { puzzle, solution }; // Başarılı bulmacayı döndür ve fonksiyondan çık.\r\n        }\r\n\r\n        // Eğer bu deneme hedefe ulaşamadıysa ama şimdiye kadarki en iyi denemeyse, onu sakla.\r\n        if (removedCount > bestRemovedCount) {\r\n            bestRemovedCount = removedCount;\r\n            bestPuzzle = { puzzle, solution };\r\n        }\r\n        \r\n        attempts++;\r\n    }\r\n\r\n    // Eğer maksimum deneme sayısına ulaşıldıysa ve hala hedef tutturulamadıysa,\r\n    // en iyi denemeyi bir uyarıyla birlikte döndür.\r\n    console.warn(`Maksimum deneme sayısına ulaşıldı (${maxAttempts}). \r\n    Hedef ${removals} hücreydi, en iyi sonuç ${bestRemovedCount} hücre silinmiş bulmaca oldu.`);\r\n    \r\n    return bestPuzzle;\r\n};\r\n\r\nexport const validateGrid = (grid) => {\r\n    const invalidCells = new Set();\r\n\r\n    // Helper function to add coordinates to the set\r\n    const addInvalid = (r, c) => invalidCells.add(`${r}-${c}`);\r\n\r\n    // 1. Satırları ve Sütunları kontrol et\r\n    for (let i = 0; i < 9; i++) {\r\n        const rowMap = new Map();\r\n        const colMap = new Map();\r\n        for (let j = 0; j < 9; j++) {\r\n            // Satır kontrolü\r\n            const rowCell = grid[i][j];\r\n            if (rowCell !== 0) {\r\n                if (rowMap.has(rowCell)) {\r\n                    addInvalid(i, j);\r\n                    addInvalid(i, rowMap.get(rowCell));\r\n                }\r\n                rowMap.set(rowCell, j);\r\n            }\r\n            // Sütun kontrolü\r\n            const colCell = grid[j][i];\r\n            if (colCell !== 0) {\r\n                if (colMap.has(colCell)) {\r\n                    addInvalid(j, i);\r\n                    addInvalid(colMap.get(colCell), i);\r\n                }\r\n                colMap.set(colCell, j);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 2. 3x3'lük Kutuları kontrol et\r\n    for (let boxRow = 0; boxRow < 9; boxRow += 3) {\r\n        for (let boxCol = 0; boxCol < 9; boxCol += 3) {\r\n            const boxMap = new Map();\r\n            for (let i = 0; i < 3; i++) {\r\n                for (let j = 0; j < 3; j++) {\r\n                    const r = boxRow + i;\r\n                    const c = boxCol + j;\r\n                    const cellValue = grid[r][c];\r\n                    if (cellValue !== 0) {\r\n                        if (boxMap.has(cellValue)) {\r\n                            const [prev_r, prev_c] = boxMap.get(cellValue);\r\n                            addInvalid(r, c);\r\n                            addInvalid(prev_r, prev_c);\r\n                        }\r\n                        boxMap.set(cellValue, [r, c]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Set'i {row, col} objelerinden oluşan bir array'e dönüştür\r\n    return Array.from(invalidCells).map(coord => {\r\n        const [row, col] = coord.split('-').map(Number);\r\n        return { row, col };\r\n    });\r\n};","/* eslint-disable no-restricted-globals */\r\nimport { generateSudoku } from \"./utils/sudokuLogic.js\";\r\n\r\nfunction numberToTime(estimatedTime) {\r\n    const minutes = Math.floor(estimatedTime / 60000);\r\n    const seconds = Math.floor((estimatedTime % 60000) / 1000);\r\n    return `${minutes}m ${seconds}s`;\r\n}\r\n\r\nself.onmessage = (e) => {\r\n    console.log('Worker: Mesaj alındı', e.data);\r\n    const { totalSudokus, chosenDifficulties, difficultySettings } = e.data;\r\n\r\n    const generatedPuzzles = [];\r\n\r\n    const numSelected = chosenDifficulties.length;\r\n    const sudokusPerDifficulty = Math.floor(totalSudokus / numSelected);\r\n    const remainder = totalSudokus % numSelected;\r\n\r\n    let counts = chosenDifficulties.map((_, idx) =>\r\n        sudokusPerDifficulty + (idx < remainder ? 1 : 0)\r\n    );\r\n\r\n    let estimatedTime = counts.reduce((sum, count, idx) => {\r\n        const difficultyKey = chosenDifficulties[idx];\r\n        const difficulty = difficultySettings[difficultyKey];\r\n        return sum + (count * difficulty.estimatedTime);\r\n    }, 0);\r\n\r\n    for (let d = 0; d < chosenDifficulties.length; d++) {\r\n        const difficultyKey = chosenDifficulties[d];\r\n        const difficulty = difficultySettings[difficultyKey];\r\n        for (let i = 0; i < counts[d]; i++) {\r\n\r\n            const result = generateSudoku(difficulty.removals);\r\n\r\n            if (result) generatedPuzzles.push({\r\n                puzzle: result.puzzle,\r\n                solution: result.solution,\r\n                difficulty: difficulty.level,\r\n            });\r\n\r\n            estimatedTime -= difficulty.estimatedTime;\r\n\r\n            // YENİ: Her bir bulmaca üretildikten sonra ilerleme mesajı gönder.\r\n            self.postMessage({\r\n                type: 'progress',\r\n                generated: generatedPuzzles.length,\r\n                total: totalSudokus,\r\n                estimatedTime: numberToTime(estimatedTime)\r\n            });\r\n        }\r\n    }\r\n\r\n    // İş bittiğinde, oluşturulan bulmacaları ana thread'e geri gönder.\r\n    console.log('Worker: İşlem tamamlandı, sonuç gönderiliyor.');\r\n    // YENİ: İş bittiğinde, sonuçları farklı bir tipte gönder.\r\n    self.postMessage({\r\n        type: 'result',\r\n        puzzles: generatedPuzzles\r\n    });\r\n};"],"names":["createEmptyGrid","Array","fill","map","isValid","grid","row","col","num","x","startRow","startCol","i","j","findAllSolutions","limit","arguments","length","undefined","solutions","find","currentGrid","push","JSON","parse","stringify","shuffle","array","Math","floor","random","fillGrid","numbers","generateSudoku","removals","bestPuzzle","bestRemovedCount","attempts","solution","puzzle","cells","from","_","removedCount","cellIndex","temp","console","log","concat","warn","numberToTime","estimatedTime","minutes","seconds","self","onmessage","e","data","totalSudokus","chosenDifficulties","difficultySettings","generatedPuzzles","numSelected","sudokusPerDifficulty","remainder","counts","idx","reduce","sum","count","difficultyKey","d","difficulty","result","level","postMessage","type","generated","total","puzzles"],"sourceRoot":""}